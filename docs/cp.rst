#############
常量传播
#############

.. contents::
   :local:

为什么单开一章:
===============
一般的常量传播，只要沿着constant var和input var传播下去即可。但是dobc中有它独有的复杂性，这个复杂性不是dobc带来的，而是逆向二进制必然存在的。导致了普通的常量传播假如应用在反编译中，大概率生成的结果不是特别好看。

我们在正向的编译器开发中，有以下代码:

.. code-block:: c

    int x = point.x * point.x;

编译器对 point.x 和 x ，会生成某种GVN编号，在接下去的各种pass分析中，当我们去标识这个point.x var时，都是通过这个gvn编号，这个相当于var的一个ID. 在这个阶段，是没有所谓stack-space这些概念的。 当进行到寄存器分配阶段时，发现无法分配到足够多的寄存器后，才会溢出到stack上，这个时候 point.x 才可能会转换成 [sp+xxx] 的访问。

而到了反编译阶段，对于以上的代码，你已经完全丢失了其类型信息，这个时候你看到的，只能是各种，[sp+xxx], [r0+xxx] 的访问。所以这个时候的ID，只能是不同内存空间上的一个偏移，这也导致了另外一个问题，我们判断2个地址的关系变的困难，进一步导致了常量传播不是那么稳定，我们看以下代码:


.. code-block:: c

    1. r0 = load [sp + 124]
    2. store [r0], r1
    3. 