#############
DOBC 详解
#############

.. contents::
   :local:

Introduction
============

本文是关于dobc

1. 核心算法，基于格做的描述和定义
2. 实现原理，一些很工程化的东西，还有对现有算法的一些调整
3. 未解决的问题，并给出了部分算法(Draft)
4. 对未来的一些思考

阅读的顺序并非线性的，我会在讲述某一个问题时，说明需要参考的内容，在后面或者前面第几章。

但是第一章是必读的

算法分析
========

为什么混淆的代码是可以还原的？
-----------------------------------

我们认为当一个信息经过某个信息通道，没有丢失信息，则是容易可逆的。

md5
^^^^^
信息在穿过md5以后，丢失了信息，所以很难还原。

base64
^^^^^^^
base64没有丢失信息，所以它很容易还原成原文

jpg
^^^^
?

ollvm
^^^^^^
ollvm我们认为在这个混淆过程中，没有丢失信息，因为假如丢失了信息，那么在经过CPU以后，应该会给出不一样的结果，但是看起来它们给的结果是一样的。


但是ollvm混淆的时候，防守方拿到了完整的源码，它在混淆并生成汇编过后，丢弃了大部分的类型信息，导致逆向的时候，很难完整的还原这部分类型，起到了一种近似于丢信息的效果，这也导致我在还原代码时，做了部分严重的硬编码，因为这部分严重依赖于ollvm，所以它被我挪到了ollvm_detect_framework这个函数中，而无法移入到标准的编译优化pass。以下是一个简单的证明:



思考:
=====

